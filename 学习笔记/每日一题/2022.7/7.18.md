### æœ‰å…³äºŒå‰æ ‘

+ å…ˆåºéå†ï¼šâ€œæ ¹â€ => "å·¦" => "å³"

+ ä¸­åºéå†ï¼šâ€œå·¦â€ => â€œæ ¹â€ => "å³"

+ ååºéå†ï¼šâ€œå·¦â€ => â€œå³â€ => â€œæ ¹â€

### ä¸¤æ•°ä¹‹å’Œ

+ å‡ ä¹æ‰€æœ‰çš„æ±‚å’Œé—®é¢˜ï¼Œéƒ½å¯ä»¥è½¬æ¢æˆæ±‚å·®é—®é¢˜

```TypeScript
function twoSum(nums: number[], target: number): number[] {
  let map:object = {};
  for(let i=0;i<nums.length;i++) {
    if(map[target-nums[i]] == undefined) {
      map[nums[i]] = i;
    } else {
      return [map[target-nums[i]], i]
    }
  }
};
```

### åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„

+ åŒæŒ‡é’ˆè½»æ¾è§£å†³

```TypeScript
function merge(nums1: number[], m: number, nums2: number[], n: number): void {
  let idx: number = m + n - 1;
  let idx1: number = m - 1;
  let idx2: number = n - 1;
  while(idx1 >= 0 || idx2 >= 0) {
    if(idx1 < 0) {
      nums1[idx] = nums2[idx2];
      idx --, idx2 --;
    } else if (idx2 < 0) {
      nums1[idx] = nums1[idx1];
      idx --, idx1 --;
    } else if(nums1[idx1] >= nums2[idx2]) {
      nums1[idx] = nums1[idx1];
      idx --, idx1 --;
    } else {
      nums1[idx] = nums2[idx2];
      idx --, idx2 --;
    }
  }
};
```

### ä¸‰æ•°ä¹‹å’Œ

```TypeScript
function threeSum(nums: number[]): number[][] {
  let len:number = nums.length;
  let ans = []
  nums.sort((a:number,b:number) => {
    return a - b
  })
  for(let i=0;i<len-2;i++) {
    let l:number = i + 1, r:number = len - 1;
    if(i > 0 && nums[i] === nums[i-1]) {
      continue;
    }
    while (l < r) {
      if(nums[i] + nums[l] + nums[r] < 0) {
        l ++
        while(nums[l] === nums[l-1] && l < r) {
          l ++
        }
      } else if(nums[i] + nums[l] + nums[r] > 0){
        r --;
        while(nums[r] === nums[r+1] && l < r) {
          r --;
        }
      } else {
        ans.push([nums[i],nums[l],nums[r]])
        l ++, r--;
        while(nums[l] === nums[l-1] && l < r) {
          l ++
        }
        while(nums[r] === nums[r+1] && l < r) {
          r --;
        }
      }
    }
  }
  return ans
};
```

### åˆ¤æ–­ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯ä¸æ˜¯å›æ–‡å­—ç¬¦ä¸²

```js
// ç›´æ¥è°ƒç”¨api
function isPalindrome(str) {
    // å…ˆåè½¬å­—ç¬¦ä¸²
    const reversedStr = str.split('').reverse().join('');
    return str === reversedStr;
}

// åˆ©ç”¨å›æ–‡å­ä¸²çš„ç‰¹æ€§ï¼šâ€œå¦‚æœä»ä¸­é—´ä½ç½®â€˜åŠˆå¼€â€™ï¼Œé‚£ä¹ˆä¸¤è¾¹çš„ä¸¤ä¸ªå­ä¸²åœ¨å†…å®¹ä¸Šæ˜¯å®Œå…¨å¯¹ç§°çš„ã€‚å› æ­¤æˆ‘ä»¬ä¹Ÿå¯ä»¥ç»“åˆå¯¹ç§°æ€§åšåˆ¤æ–­ã€‚â€
function isPalindrome(str) {
    const len = str.length;
    for(let i=0;i<len/2;i++) {
        if(str[i] !== str[len-i-1]) {
            return false;
        }
    }
    return true;
}
```

### éªŒè¯å›æ–‡å­—ç¬¦ä¸²

+ é“¾æ¥ï¼š[éªŒè¯å›æ–‡å­—ç¬¦ä¸²](https://leetcode.cn/problems/valid-palindrome-ii/)

+ æ¯”è¾ƒæœ‰è¶£çš„éƒ¨åˆ†å°±æ˜¯ä¸€ä¸ªå›è°ƒã€‚

```js
var validPalindrome = function(s) {
  // ä¹‹å‰å†™çš„ç€å®ä¸å¥½çœ‹
  let len = s.length
  let st = 0, ed = len - 1;
  while(st < ed && s[st] === s[ed]) {
    st ++;
    ed --;
  }
  if(isPaland(st+1, ed)) {
    return true;
  }
  if(isPaland(st, ed-1)) {
    return true
  }
  function isPaland(l, r) {
    while(l < r) {
      if(s[l] !== s[r]) {
        return false;
      }
      l ++, r --;
    }
    return true;
  }
  return false
};
```

### æ·»åŠ ä¸æœç´¢å•è¯

+ [æ·»åŠ ä¸æœç´¢å•è¯](https://leetcode.cn/problems/design-add-and-search-words-data-structure/)

+ ä¸»è¦å°±æ˜¯ä½¿ç”¨ä¸€ä¸ªæ­£åˆ™æ¥å†™
> + ä¸‰ç§æƒ…å†µ
> + 1. ä¸å­˜åœ¨
> + 2. ä¸å«æœ‰â€œ.â€
> + 3. å«æœ‰"."

```js
WordDictionary.prototype.search = function(word) {
  // é¦–å…ˆæ˜¯ä¸æˆç«‹çš„æƒ…å†µ
  let len = word.length;
  if(!this.word[len]) {
    return false;
  }
  if(!word.includes('.')) {
    return this.word[len].includes(word);
  }
  var regex = new RegExp(word);
  return this.word[len].some((item) => {
    return regex.test(item)
  })
};
```

### å­—ç¬¦ä¸²è½¬æ¢æˆæ•´æ•°

+ é“¾æ¥ï¼š[å­—ç¬¦ä¸²è½¬æ¢æˆæ•´æ•°ğŸ”—](https://leetcode.cn/problems/string-to-integer-atoi/)

+ æŠŠæ­£åˆ™å†™å‡ºæ¥ï¼Œå†æŠŠå¯¹åº”æƒ…å†µå†™ä¸€å†™å°±å¥½äº†ã€‚

```js
var myAtoi = function(s) {
  const reg = /\s*([-\+]?[0-9]*).*/
  const group = s.match(reg);
  const max = Math.pow(2, 31) - 1;
  const min = - max - 1;
  let targetNum = 0;
  if(group) {
    targetNum = +group[1];
    if(isNaN(targetNum)) {
      targetNum = 0;
    }
  }
  if(targetNum > max) {
    targetNum = max;
  } else if(targetNum < min) {
    targetNum = min;
  }
  return targetNum;
};
```