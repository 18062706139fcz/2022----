### 有关二叉树

+ 先序遍历：“根” => "左" => "右"

+ 中序遍历：“左” => “根” => "右"

+ 后序遍历：“左” => “右” => “根”

### 两数之和

+ 几乎所有的求和问题，都可以转换成求差问题

```TypeScript
function twoSum(nums: number[], target: number): number[] {
  let map:object = {};
  for(let i=0;i<nums.length;i++) {
    if(map[target-nums[i]] == undefined) {
      map[nums[i]] = i;
    } else {
      return [map[target-nums[i]], i]
    }
  }
};
```

### 合并两个有序数组

+ 双指针轻松解决

```TypeScript
function merge(nums1: number[], m: number, nums2: number[], n: number): void {
  let idx: number = m + n - 1;
  let idx1: number = m - 1;
  let idx2: number = n - 1;
  while(idx1 >= 0 || idx2 >= 0) {
    if(idx1 < 0) {
      nums1[idx] = nums2[idx2];
      idx --, idx2 --;
    } else if (idx2 < 0) {
      nums1[idx] = nums1[idx1];
      idx --, idx1 --;
    } else if(nums1[idx1] >= nums2[idx2]) {
      nums1[idx] = nums1[idx1];
      idx --, idx1 --;
    } else {
      nums1[idx] = nums2[idx2];
      idx --, idx2 --;
    }
  }
};
```

### 三数之和

```TypeScript
function threeSum(nums: number[]): number[][] {
  let len:number = nums.length;
  let ans = []
  nums.sort((a:number,b:number) => {
    return a - b
  })
  for(let i=0;i<len-2;i++) {
    let l:number = i + 1, r:number = len - 1;
    if(i > 0 && nums[i] === nums[i-1]) {
      continue;
    }
    while (l < r) {
      if(nums[i] + nums[l] + nums[r] < 0) {
        l ++
        while(nums[l] === nums[l-1] && l < r) {
          l ++
        }
      } else if(nums[i] + nums[l] + nums[r] > 0){
        r --;
        while(nums[r] === nums[r+1] && l < r) {
          r --;
        }
      } else {
        ans.push([nums[i],nums[l],nums[r]])
        l ++, r--;
        while(nums[l] === nums[l-1] && l < r) {
          l ++
        }
        while(nums[r] === nums[r+1] && l < r) {
          r --;
        }
      }
    }
  }
  return ans
};
```