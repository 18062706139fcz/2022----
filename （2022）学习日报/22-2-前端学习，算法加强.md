# 念念不忘，必有回响！
### 宗旨
> 不做文章搬运工，要有自己的总结和思考。<br>
> 分板块记录，算法，计网，前端。<br>
> 确定自己暂时学习的方向==>计算机网络/前端/算法
## 2.5学习日报
> 时长：180min+210min+120min=510min
### 计算机网络
>每日一问：你是怎么理解HTTP的?<br>
HTTP，顾名思义，是超文本传输协议。<br>
这个名词可以划分为三个部分--“超文本”“传输”“协议”<br>
首先看协议，协议是你与我之间，我与他之间的一个约定和规范<br>
传输则需要两个对象，分别是请求方和响应方，数据在这两者之间传输，但应该注意的是，请求方和响应方中间也有可能存在中间人，也就是代理，可以有一个中间人，也可以有无穷多个中间人。<br>
超文本是什么呢？<br>
不妨先看看文本是什么。文本，顾名思义，就是有意义的文字，音频，视频。<br>
那超文本是什么呢？<br>
超文本就是超越了这些文本的文本，是文字，音频，视频的集合体，同时其中存在着超链接，可以从一个文本跳转到另一个文本。<br>
所以，HTTP是一个用在计算机世界里的协议，它确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。<br>
<br>

_HTTP/3笔记总结_<br>

> 1.HTTP/3基于QUIC协议，完全解决了“队头阻塞”问题，弱网环境下的表现会优于HTTP/2;<br>
2.QUIC是一个新的传输层协议，建立在UDP之上，实现了可靠传输；<br>
3.QUIC内含TLS1.3，只能加密通信，支持0-RTT快速建连；<br>
4.QUIC的连接使用“不透明”的连接ID，不绑定在“IP地址+端口”上，支持“连接迁移”；<br>
5.QUIC的流与HTTP/2的流很相似，但分为双向流和单向流；<br>
6.HTTP/3没有指定默认端口号，需要用HTTP/2的扩展帧“Alt-Svc”来发现。<br>
summary：HTTP/3把TCP淘汰掉了，原因是TCP会有丢包重传的一些问题，从而导致队头阻塞，而UDP就不会造成这种问题，TCP中的功能迁移到了应用层。

### 算法
**DP问题**(120min)<br>
> DP问题需要从几个方面来思考：<br>
1.状态表示<br>
(1)意义<br>
(2)属性（Max/Min/数量）<br>
2.状态计算<br>
**质数问题&约数问题**(120min)<br>
模版问题(见模版专栏)<br>
**Atcoder**（120min）<br>
C可以硬算，n不能再*10了，因为可能会爆long long，就用/来表示。
### 前端知识
>全选联系（js）<br>
### 计算机指令
> Ctrl+A代表全选


## 2.6学习日报

> 学习时长：150min+240min+150min=540min

### 计算机网络

> HTTP/2的优点：<br>
1.完全保持了与HTTP/1的兼容，因为兼容HTTP/1，所以拥有HTTP/1的所有优点，同时基本解决了HTTP/1的所有缺点，可以认为是“更安全的HTTP，更快的HTTPS”<br>
2.多路复用/服务器推送/优先级/头部压缩<br>
HTTP/2的缺点：<br>
1.丢包重传，降低效率。<br>
2.在移动网络中发生IP地址切换的时候，下层的TCP必须重新建连，要再次“握手”，经历“慢启动”，而且之前的连接里积累的HPACK字典也消失了，必须重头开始计算，导致带宽浪费和延迟。<br>
3.队头阻塞，在HTTP/2在弱网或者移动网络下的性能表现会不如HTTP/1<br>
summary：<br>
TLS协议提供“ALPN”扩展，让客户端和服务器协商使用的应用层协议，“发现”HTTP/2服务。<br>

> 每日一问：TCP在三次握手的时候，IP层和MAC层在做什么呢？<br>
ans：TCP发送每个消息（网络包），（网络包的报文）都会带着IP头部和MAC头部。因为TCP每发送一个消息，IP层和MAC层的所有机制都要运行一遍。<br>
需要记得：只要是在网络上跑的包都是完整的，可以有下层没有上层，但是绝对不可能有上层没有下层。<br>
所以对于TCP协议来说，三次握手也好，重试也好，只要想发出去包，就要有IP层和MAC层，不然是发不出去的。<br>

（通过传输层TCP三次握手之后）发出去的网络包报文构成如下图（来自 小林Coding的《图解网络》）：
![image](https://user-images.githubusercontent.com/75036021/152717428-47e5b5e7-b5c2-450c-b925-425d286b7b50.png)


#### 趣谈网络协议
> 总结：<br>
> （1）IP是地址，有定位功能；MAC是身份证，无定位功能；<br>
> （2）CIDR可以用来判断是不是本地人<br>
> （3）IP分公有IP和私有IP<br>

#### 无类型域间选路（CIDR）

> 伴随着CIDR存在的，一个是广播地址，10.100.122.255<br>
> 另一个是子网掩码，255.255.255.0<br>
> 讲子网掩码和IP地址按位计算AND，就可以得到网络号<br>


> 问题：如何查看IP地址？<br>
> Windows==>ipconfig<br>
> Linux==>ifconfig<br>
> Linux上还有一个方式==>"ip addr"


```
//运行ip addr后得到了这个
root@test:~# ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
         //以下是网络设备的状态标识，叫net_device flags
         //UP 表示网卡处于启动的状态
         //BROADCAST 表示这个网卡有广播地址
         //MULTICAST 表示网卡可以发送多播包
         //LOWER_UP 表示 L1 是启动的，也即网线插着呢
         //MTU是以太网的默认值，最大传输单元
         //qdisc pfifo_fast ==>
         //qdisc ==> queueing discipline(排队规则)
         
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff
//此处10.100.122.2就是一个IP地址，每个部分8个bit，所以IP地址总共是32位
    inet 10.100.122.2/24 brd 10.100.122.255 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::f816:3eff:fec7:7975/64 scope link 
       valid_lft forever preferred_lft forever
```

### 算法部分
#### 补题：
D:结论：(1) (x+y) = 2*(x&y) + (x^y)  (2)   (x ^ y) & (x & y) = 0 <br>
E:并查集，但是注意边界条件，可以往左边移动
#### DP问题==>可以递推


## 2.7学习日报

> 学习时长 390min

### 算法部分：

>210min+120min

> 数论（Lucas定理）

```
//适用范围，求组合数
const int N =1e6+10;
const int mod = 1000003;
int f[N];
//得到阶乘
void GETjiecheng()
{
	f[0]=1;
	for(int i=1;i<=1000000;i++)
	{
		f[i]=f[i-1]*i%mod;
	}
}
//快速幂
int quickpow(int a,int b,int mod)
{
	int res = 1;
	while(b)
	{
		if(b&1)
			res = res * a % mod;
		b >>= 1;
		a = a * a % mod;
	}
	return res;
}
//获取C(n,m)%mod
int getC(int n,int m,int mod)
{
	if(m>n) return 0;
	return f[n]*(quickpow(f[m]*f[n-m]%mod, mod-2, mod))%mod;
}
int Lucas(int n,int m,int mod)
{
	if(m==0)
		return 1;
	return getC(n%mod, m%mod, mod)*Lucas(n/mod, m/mod, mod)%mod;
}
```

```
//欧几里得定理
//扩展欧几里得定理
//适用范围：求最大公约数以及这个式子X*A+Y*B=D(最大公约数）
int gcd(int a, int b)
{
	return b ? gcd(b, a % b) : a;
}
int exct(int a,int b,int &x,int &y)
{
	if(!b)
	{
		x=1;
		y=0;
		return a;
	}
	int d = exct(b,a%b,y,x);
	y -= a/b*x;
	return d;
}
```

### 计算机网络

>60min

#### Nginx
> 市面主流浏览器：Nginx AND Apache （占 90 % 份额）<br>
> Nginx 轻量级(CPU/内存占用都很小)的Web服务器<br>
> Nginx 并未使用“多线程”，而是使用了进程池+单线程的工作模式<br>
> 进程池：Nginx在启动的时候会预先创建好固定数量的worker进程，在之后的运行过程中不会再fork出新进程,并且能够自动把进程绑定到独立的CPU上，完全消除了进程创建和进程切换的成本，充分利用多核CPU的计算能力<br>
> 单线程的好处：“开发简单，没有互斥锁的成本，减少了系统消耗。”<br>
> 小前提：Web服务器是I/O密集型而不是CPU密集型==>所以要优化I/O！<br>
> 单线程处理能力超过多线程的原因：“I/O多路复用！”<br>
> I/O多路复用：“epoll”<br>
> detail：把HTTP请求处理打成碎片，都“复用”到一个单线程里，不按照先来后到的顺序处理，而是只当连接上真正可读，可写的时候才处理，如果发生阻塞就换出去，处理其他请求。<br>
![image](https://static001.geekbang.org/resource/image/4c/59/4c6832cdce34133c9ed89237fb9d5059.png)
> epoll还有一个特点：大量的连接管理工作都是在操作系统内核里做的，这就减轻了应用程序的负担，所以 Nginx 可以为每个连接只分配很小的内存维护状态，即使有几万、几十万的并发连接也只会消耗几百 M 内存，而其他的 Web 服务器这个时候早就“Memory not enough”了。<br>
> Nginx 使用了“职责链”模式，多个模块分工合作，自由组合，以流水线的方式处理 HTTP 请求。

#### IP是怎么来的

> DHCP：动态主机配置协议<br>
> 如果是数据中心里面的服务器，IP一旦配置好，基本不会变，这就相当于买房自己装修。<br>
> DHCP的方式就相当于租房。你不用装修，都是帮你配制好的。你暂时用一下，用完退租就可以了。<br>
> DHCP Discover
> ![image](https://static001.geekbang.org/resource/image/90/81/90b4d41ee38e891031705d987d5d8481.jpg)
> MAC地址唯一==>知道是新人==>租给你一个IP地址（这个过程叫DHCP Offer）<br>
> DHCP Offer格式<br>
> ![image](https://static001.geekbang.org/resource/image/a5/6b/a52c8c87b925b52059febe9dfcd6be6b.jpg)
>然后新人又有动作了：
> ![image](https://static001.geekbang.org/resource/image/cd/fa/cdbcaad24e1a4d24dd724e38f6f043fa.jpg)
> DHCP Server回应
> ![image](https://static001.geekbang.org/resource/image/cc/a9/cca8b0baa4749bb359e453b1b482e1a9.jpg)

> 总结：<br>
> (1)DHCP 协议主要是用来给客户租用 IP 地址，和房产中介很像，要商谈、签约、续租，广播还不能“抢单”；<br>
> (2)DHCP 协议能给客户推荐“装修队”PXE，能够安装操作系统，这个在云计算领域大有用处。


## 2.8学习日报

### 计算机网络

#### OpenResty
> "一个人很难超越时代，而时代却可以轻易超越所有人。"<br>
> Nginx的年纪太大了，Nginx的服务管理思路沿用了过去的流行做法：”使用磁盘上的静态配置文件，所以每次修改后必须重启才能生效。“缺乏灵活性。<br>
> OpenResty 基于Nginx,打包了很多有用的模块和库，是一个高性能的Web开发平台。<br>
> OpenResty的工作语言是Lua，它小巧灵活，执行效率高，支持“代码热加载”；<br>
> “代码热加载”特性，不需要重启进程，就能够从磁盘、Redis 或者任何其他地方加载数据，随时替换内存里的代码片段。这就带来了“动态配置”，让 OpenResty 能够永不停机，在微秒、毫秒级别实现配置和业务逻辑的实时更新，比起 Nginx 秒级的重启是一个极大的进步。<br>
> OpenResty的核心编程范式是“同步非阻塞”，使用协程，不需要异步回调函数；<br>
> OpenResty 也使用“阶段式处理”的工作模式，但因为在阶段里执行的都是 Lua 代码，所以非常灵活，配合 Redis 等外部数据库能够实现各种动态配置。

